# **高级IO**

在IO过程中，存在以下两种情况：

- 当资源未准备就绪时，将会进行阻塞/非阻塞等待。
- 当资源准备就绪时，将进行数据拷贝。

也即是说，**IO的本质是进行资源的等待与数据的拷贝**。

其中，数据的拷贝完全依赖于硬件设备的性能。而如何在软件层面提高IO效率，则取决于如何减少IO在进行资源等待的时间比重。



## 五种IO模型

通过下述例子，来引出五种IO模型：

故事里有五个主人公，分别为**A、B、C、D、E**，他们相约一起去河边进行钓鱼趣味竞赛，下面是他们个人的钓鱼工具以及当天的钓鱼操作：

​	A: 准备一根鱼竿（附带鱼漂），若干鱼饵，两耳不闻窗边事的钓鱼，鱼不上钩就一直一定不动的盯着鱼漂。

​	B: 准备了一根鱼竿（附带鱼漂），若干鱼饵，一边刷着手机一边钓鱼，每过3分钟瞧一眼看看鱼漂是否有动静。

​	C: 准备一根鱼竿（附带鱼漂），若干鱼饵，一只铃铛，将铃铛挂在鱼竿头上，刷着手机头也不抬。铃铛一响立刻起鱼竿。

​	D:准备五根鱼竿（附带鱼漂），若干鱼饵，一当发现其中一个鱼漂有动静，就抬起鱼竿抓鱼。

​	E:是一个大老板，因为公司出了事情需要处理，将一根鱼竿交给秘书进行处理，秘书钓完鱼后打电话通知E，E再过来领取。

上面五个人如果要比较谁的钓鱼效率最高，那么肯定是D，原因是其所拥有的鱼竿最多，每条鱼在选择鱼饵咬钩时的概率就比其他人高。



**可以将上面的例子映射到进程IO上：**

​	河 == 内核空间。

​	鱼 == 数据资源。

​	铃铛 == 信号。

​	鱼漂 == 鱼是否咬钩 == 资源准备就绪的事件。

​	鱼竿 == 文件描述符。

​	E的秘书 == 操作系统。



**A、B、C、D、E分别代表着的IO模型：**

​	A ：阻塞式IO。

​	B ：非阻塞式IO。

​	C ：信号驱动式IO。

​	D ：多路转接 / 多路复用。

​	E ： 异步IO。



### 阻塞式IO

概念：在内核将数据准备好之前，系统调用会一直等待。**所有的套接字默认都是阻塞方式。**阻塞IO是最常见的IO模型。

​	 ![阻塞式IO](D:\github\Linux\高级IO\阻塞式IO.png)

​	 



### 非阻塞式IO

概念：如果内核还未将数据准备好，系统调用仍然会直接返回，并且返回**EWOULDBLOCK**错误码。

非阻塞IO往往需要程序员以循环的方式反复尝试读写文件描述符，这个过程称之为**轮询**。这对CPU来说是很大的浪费，一般只在特定场景下使用。

![非阻塞式等待](D:\github\Linux\高级IO\非阻塞式等待.png)





### 信号驱动IO

概念：内核将数据准备好的时候，使用**SIGIO**信号通知应用进程进行IO。

![信号驱动IO](D:\github\Linux\高级IO\信号驱动IO.png)



### 多路转接

概念：虽然从流程图上看起来和阻塞IO类似。但实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态。

![多路转接IO](D:\github\Linux\高级IO\多路转接IO.png)



注意：多路转接是将IO两部分分开进行处理，**select只进行资源等待**，recvfrom只进行数据拷贝。



### 异步IO

概念：由内核在数据拷贝完成时，通知应用程序（信号驱动IO是告诉应用程序何时可以开始拷贝数据）。



![异步IO](D:\github\Linux\高级IO\异步IO.png)



### 小结

​	任何IO过程中，都包含两个步骤：第一是**等待**，第二是**拷贝**，而且在实际的应用场景中，等待消耗的时间往往都远高于拷贝的时间。如何让IO更高效，最核心的办法就是**让等待的时间尽可能的少**。



## 几个重要概念的区分

### 同步通信 VS 异步通信

同步与异步关注的是消息通信机制。

- 所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该调用就不会**返回**。但是一旦调用返回，就得到返回值了。换句话说，就是由**调用者**主动等待这个**调用**的结果。就如钓鱼例子中的**A、B、C、D**。
- 异步则是相反，**调用**发出后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而在**调用**发出后，**被调用者**通过状态、通知来通知调用者，或通过回调函数处理这个调用。就如钓鱼例子中的E，其中E是调用发起者，E的秘书就是被调用者。



### 进程/线程同步 VS 同步通信

这两者的关系完全就是老婆与老婆饼的关系，完全够不着边。

- 进程/线程同步时进程/线程之间直接的制约关系。
- 这些线程要求在访问某些临界资源时，确保这些线程按照指定顺序在某一时刻只有一个线程能够访问这个临界资源。



在未来如果看到"同步"，我们需要先搞清楚大背景是什么。这个同步，究竟是同步通信、异步通信的同步，还是同步与互斥的同步。



### 阻塞 VS 非阻塞

阻塞和非阻塞关注的是程序等待调用结果（消息，返回值）时的状态。

- 阻塞调用是指调用结果返回之前，当前线程/进程会被挂起，调用线程/进程只有在得到结果之后才会返回。
- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程/进程。



## 非阻塞IO

一个文件描述符，默认情况下都是阻塞式的。

在以下情况中，可以手动设置IO为非阻塞状态：

- recvfrom / recv 中的flags参数设置为 **MSG_DONTWAIT**；
- sendto / send 中的flags参数设置为 **MSG_DONTWAIT**；
- 调用**fcntl**直接将文件描述符设置为非阻塞。



前两种设置只能将特定的I/O操作设置为非阻塞式，并不全面、通用。要做到将整个文件描述符以及后续IO操作都设置为非阻塞，需要使用到**fcntl**,该操作能一步到位。下面着重介绍 **fcntl**函数。



### fcntl

函数原型如下：

```c++
#include <unistd.h>
#include <fcntl.h>

int fcntl(int fd,int cmd,... /* arg */);
```

传入的cmd的值不同，后面追加的参数也不同。

fcntl函数有5种功能：

- 复制一个现有的描述符 （cmd=F_DUPFD）。
- 获得/设置文件描述符标记（cmd=F_GETFD 或 F_SETFD）。
- 获得/设置文件状态标记（cmd=F_GETFL 或 F_SETFL）。
- 获得/设置异步I/O所有权（cmd=F_GETOWN 或 F_SETOWN）。
- 获得/设置记录锁（cmd=F_GETLK,F_SETLK或F_SETLKW）。

这里只需要使用第三种功能，**获取/设置文件状态标记**，就可以将一个文件描述符设置为非阻塞。



### 实现函数SetNonBlock

基于**fcntl**,可以实现一个**SetNonBlock**函数，将文件描述符设置为非阻塞。

```c++
void SetNonBlock(int fd)
{
    int fl = fcntl(fd,F_GETFL);//根据文件描述符获取文件属性
    if(fl < 0){
        perror("fcntl");
        return ;
    }
    
    fcntl(fd,F_SETFL, fl | O_NONBLOCK);
} 
```

- 使用F_GETFL将当前文件描述符所对应的文件属性取出来（这是一个位图）。
- 然后再使用F_SETFL将文件描述符设置回去，设置回去的同时，将**O_NONBLOCK**设置进位图中。



### 以轮询方式读取标准输入

```c++
int main()
{
    SetNonBlock(0);
    char buffer[1024];
    while(1)
    {
        std::cout << "请输入>";
        fflush(stdout);//清空缓冲区
        sleep(5);//等待输入，防止输入和输出混杂在一起
        int size = read(0,buffer,sizeof(buffer)-1); //从标准输入中读取数据
        buffer[size-1] = 0;//将'\n'清掉
        if(size > 0){ //读取到数据
            std::cout << "echo : " << buffer << std::endl; 
        }else if(size == 0){ //读取到文件尾端
            std::cout << "read over" << std::endl;
            break;
        }else {
            if(errno == EAGAIN || errno == EWOULDBLOCK)
            {
                std::cout << "等待数据准备就绪" << std::endl;
            }
            else if(errno == EINTR) continue;
            else return -1;
        }
        std::cout << std::endl;
    }

    return 0;
}
```

- 先将**标准输入**设置为非阻塞式，再从标准输入中读取数据拷贝进指定空间。
- 当**read**返回正数时，表示当前标准输入中有数据可读。
- 当**read**返回0时，表示当前已经读到文件结束标志，没有数据可以读了。
- 当**read**返回-1时，可能存在以下情况：
    1. 当前需要等待数据准备就绪，则系统会设置错误码为**EAGAIN**或者**EWOULDBLOCK**。
    2. 在阻塞读取时被信号所中断，需要重新读取，则系统会设置错误码为**EINTR**。
    3. 当前权限不够，无法打开该文件等原因，我们将这些错误视为直接错误，直接退出IO。



代码运行效果如下：

![image-20230718203855751](D:\github\Linux\高级IO\非阻塞式IO效果图.png)





## IO多路转接之select

### 初始select

IO系统调用中的recv/recvfrom/send/sendto是一次**等待一个**文件描述符中的数据准备就绪并进行数据拷贝，其完成了IO的**等+数据拷贝**。而select则是一次**等待多个**文件描述符中的数据准备就绪，但**不进行数据拷贝**，数据拷贝操作交给read/write来完成。



### select函数原型

```C++
#include <sys/select.h>
int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);
```

**参数解释：**

- nfds : 需要监视的最大文件描述符值+1。
- readfds : 一张位图，作为输入输出型参数传入。作为输入/输出型参数时，其意义各不相同：
    - 当作为输入型参数时，其意义为：
        - 用户告诉操作系统，位图中对应的文件描述符哪些读事件需要被你关心。
        - 其位图的位置对应文件描述符的数值，位图的数值则表示是否需要操作系统关心对应文件的读事件。
        - 例如位图1001,表示对应的0号和3号文件描述符的读事件需要被操作系统关心。
    - 当作为输出型参数时，其意义为：
        - 内核告诉用户，你要关心的多个文件描述符中，有哪些的读事件已经准备就绪了。
        - 其位图的位置对应文件描述符的数值，位图的数值则表示哪些文件描述符的读事件已经就绪。
        - 例如位图0001，表示用户关心的0号文件描述符的读事件已就绪。
- writefds ：与readfds同理，但表示的是写事件。
- exceptfds ：与readfds同理，但表示的是异常事件。
- timeout ：输入输出型参数，表示阻塞等待时间。当取不同值时意义不同：
    - NULL : select进行阻塞等待。
    - {0,0} ：select进行非阻塞等待。
    - {s，m} ：s表示秒数，m表示分钟。{s,m}表示先阻塞等待m分s秒，如果超过m分s秒，则非阻塞返回一次。如果在阻塞等待阶段就已经返回，则操作系统对其进行写入，修改其为剩余等待时间。



**注意：**select函数最为关键的是中间3个参数，因为select未来关心的事件也只有3种：a.读事件、b.写事件、c.异常事件。对于任意fd,都是这三种。系统通过一个**位图结构**fd_set来表示fd集合，**利用三张位图的输入和输出，用户和操作系统就能做到互相沟通，知晓对方所关心的**。



操作系统提供了一组操作**fd_set**的接口，来实现对位图的操作：

```C++
void FD_CLR(int fd, fd_set *set); //用来清除描述词组set中相关fd的位
int FD_ISSET(int fd,fd_set *set); //用来测试描述词组set中相关fd的位是否为真
void FD_SET(int fd, fd_set *set); //用来设置描述词组set中相关fd的位
void FD_ZERO(fd_set *set); //用来清除描述词组set中的全部位
```



**关于select的函数返回值**

- 返回值大于0，则表示有多少个文件描述符状态改变。
- 返回值为0，则表示在超过了timeout时间后，没有文件描述符状态改变。
- 当有错误发生时则返回-1，错误原因存于errno,此时参数readfds,writefds,exceptfds和timeout的值都是不可预测的。错误值可能为：
    - EBADF : 文件描述符为无效或该文件已经关闭。
    - EINTR : 此调用被信号所中断。
    - EINVAL : 参数nfds为负值。
    - ENOMEM : 核心内存不足。